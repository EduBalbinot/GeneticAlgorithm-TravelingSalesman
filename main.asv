%traveling salesman problem
clear, clc

%screen
X_MAX = 2000;
Y_MAX = 1000;

%configs
N_POP = 100;
N_CITIES = 30;
MAX_NOREPEAT = 1000;
MUTATION_CHANCE = 0.2;



%setup
CITY_SIZE = floor(X_MAX/N_CITIES);
NUMBER_SIZE = 0.1*CITY_SIZE;
if NUMBER_SIZE<7; NUMBER_SIZE=7; end
generation = 0;
fitnessTotal = 0; 
fitnnesAverage = 0;
bestDistanceGraph = [0 0];
noChangeCounter = 0;
lastBest = 0;

%Berlin52
cities = [struct('x', 565, 'y', 575) struct('x', 25, 'y', 185) struct('x', 345, 'y', 750) struct('x', 945, 'y', 685) struct('x', 845, 'y', 655) struct('x', 880, 'y', 660) struct('x', 25, 'y', 230) struct('x', 525, 'y', 1000) struct('x', 580, 'y', 1175) struct('x', 650, 'y', 1130) struct('x', 1605, 'y', 620) struct('x', 1220, 'y', 580) struct('x', 1465, 'y', 200) struct('x', 1530, 'y', 5) struct('x', 845, 'y', 680) struct('x', 725, 'y', 370) struct('x', 145, 'y', 665) struct('x', 415, 'y', 635) struct('x', 510, 'y', 875) struct('x', 560, 'y', 365) struct('x', 300, 'y', 465) struct('x', 520, 'y', 585) struct('x', 480, 'y', 415) struct('x', 835, 'y', 625) struct('x', 975, 'y', 580) struct('x', 1215, 'y', 245) struct('x', 1320, 'y', 315) struct('x', 1250, 'y', 400) struct('x', 660, 'y', 180) struct('x', 410, 'y', 250) struct('x', 420, 'y', 555) struct('x', 575, 'y', 665) struct('x', 1150, 'y', 1160) struct('x', 700, 'y', )];
X_MAX = 1800;
Y_MAX = 1200;
CITY_SIZE = 7;
for i = 1:2
    drawCities(cities(i).x, cities(i).y, CITY_SIZE, i, X_MAX, Y_MAX, NUMBER_SIZE)
end

cities = createCities(N_CITIES, Y_MAX, X_MAX, CITY_SIZE, NUMBER_SIZE);
population = createInitialPopulation(N_POP, N_CITIES);

[population, totalDistance, averageDistance] = calculateDistance(population, cities);

while noChangeCounter<MAX_NOREPEAT
    cumulativeProportions = getCumulativeProportions(population, totalDistance);
    
    currentBest = DrawBest(population, cities, generation, Y_MAX);
    bestDistanceGraph(generation + 1,1:2)=[generation; currentBest];
    
    offspring = crossover(population, cumulativeProportions);
    offspring = mutation(population, MUTATION_CHANCE, N_CITIES);
    [offspring, totalDistance, averageDistance] = calculateDistance(offspring, cities);
    population = cat(1, population, offspring);
    
    population = selectParents(population, N_POP);
    
    fprintf('  Best Value: %f \n',currentBest);
    fprintf('Generation: %d \n', generation); 
    fprintf(repmat('-',1,100))
    fprintf('\n\n')
    
    if lastBest == currentBest
        noChangeCounter = noChangeCounter + 1;
    else
        noChangeCounter = 0;
    end
    lastBest = currentBest;
    
    generation = generation + 1;
end

figure(2)
plot(bestDistanceGraph(:,1), bestDistanceGraph(:,2))

function currentBest = DrawBest(population, cities, generation, Y_MAX)
    bestIndividual = find([population.totalPathDistance] == min([population.totalPathDistance]));
    figure(1)
    drawRoute(cities, [population(bestIndividual(1)).cityOrder]);
    delete(findobj(gca, 'DisplayName', 'Distance'));
    text(0, Y_MAX+20,['Generation:' num2str(generation) ' - ' num2str(population(bestIndividual(1)).totalPathDistance) ' Km'], 'DisplayName', 'Distance', 'FontSize', 20)
    currentBest = population(bestIndividual(1)).totalPathDistance;
return
end

function population = selectParents(population, N_POP)
     [~, indices] = sort([population.totalPathDistance],'ascend');
     orderedParents = population(indices);
     population = orderedParents(1:N_POP);
return
end
